[gd_scene load_steps=5 format=3 uid="uid://bixm1xmwh4h83"]

[ext_resource type="Script" path="res://scenes/GameState.gd" id="3_6rb05"]

[sub_resource type="GDScript" id="GDScript_vuba5"]
resource_name = "drawer"
script/source = "extends Node2D

@onready
var _game_state : GameState = %GameState 

func _process(delta: float) -> void:
	queue_redraw()

func _draw() -> void:
	draw_circle(_game_state.ball_position, 
		_game_state.ball_radius-_game_state.ball_draw_width/2.0, 
		_game_state.ball_color, false, _game_state.ball_draw_width, true)
	
	draw_rect(_game_state.platform_rect.grow(-_game_state.platform_draw_width/2.0), 
	_game_state.platform_color, false, _game_state.platform_draw_width, false
	)
"

[sub_resource type="GDScript" id="GDScript_0ctov"]
resource_name = "block_controller"
script/source = "extends Node

@onready
var _game_state : GameState = %GameState

var blocks_x : int
var blocks_y : int
"

[sub_resource type="GDScript" id="GDScript_ypwq7"]
resource_name = "game_controller"
script/source = "extends Node

@onready
var _game_state : GameState = %GameState

func _ready() -> void:
	_game_state.state_machine.handle_state(GameState.GAME_STARTING_STATE, _on_state_game_starting)
	_game_state.state_machine.handle_state(GameState.LAUNCHING_BALL_STATE, _on_state_launching_ball)
	_game_state.state_machine.handle_state(GameState.CONTROLLING_BALL_STATE, _on_state_controlling_ball)
	
	_game_state.state_machine.state = GameState.GAME_STARTING_STATE


func _on_state_game_starting() -> void:
	const PLATFORM_GAP : float = 100.0
	
	_game_state.platform_rect.position = Vector2(
		_game_state.playing_area_rect.position.x+_game_state.playing_area_rect.size.x/2.0 -_game_state.platform_rect.size.x/2.0, 
		_game_state.playing_area_rect.end.y-PLATFORM_GAP)
	
	_place_ball_to_launch_position()


func _on_state_launching_ball() -> void:
	_place_ball_to_launch_position()


func _on_state_controlling_ball() -> void:
	pass


func _process(delta: float) -> void:
	match _game_state.state_machine.state:
		GameState.GAME_STARTING_STATE:
			_process_game_starting(delta)
		GameState.LAUNCHING_BALL_STATE:
			_process_launching_ball(delta)
		GameState.CONTROLLING_BALL_STATE:
			_process_controlling_ball(delta)


func _process_game_starting(delta:float) -> void:
	pass


func _process_launching_ball(delta:float) -> void:
	var ball_relative_position : Vector2 = _game_state.ball_position - _game_state.platform_rect.position
	_handle_platform_movement(delta)
	_game_state.ball_position = _game_state.platform_rect.position + ball_relative_position
	
	if Input.is_action_just_pressed(\"platform_launch_ball\"):
		var launch_direction : Vector2 = (_game_state.ball_position - _game_state.platform_rect.get_center()).normalized()
		_game_state.ball_velocity = launch_direction*_game_state.ball_velocity.length()
		_game_state.state_machine.go_state(GameState.CONTROLLING_BALL_STATE)


func _process_controlling_ball(delta:float) -> void:
	const PLATFORM_HEIGHT : float = 20.0
	_handle_platform_movement(delta)
	
	var ball_collision_rectangles : Array[Rect2] = []
	ball_collision_rectangles.append(_game_state.playing_area_rect.grow(-_game_state.ball_radius*2))
	
	var platform_rect : Rect2 = _game_state.platform_rect
	
	var frametime : float = 0.0
	var ball_position : Vector2 = _game_state.ball_position
	var banned_rect_side : Array[int] = [] # rect idx, side idx
	while true:
		var earliest_collision : Array = []
		var collision_rect : int
		for i:int in len(ball_collision_rectangles):
			var rect : Rect2 = ball_collision_rectangles[i]
			var ccd_res : Array = ArcanoidGeometry.ccd_circle_box(
				ball_position, 
				ball_position+_game_state.ball_velocity*delta,
				_game_state.ball_radius,
				rect, [banned_rect_side[1]] if (not banned_rect_side.is_empty() and i == banned_rect_side[0]) else []) 
			
			if not ccd_res[0]: continue
			
			if 0.0 <= ccd_res[1] and ccd_res[1] <= (1.0-frametime):
				if earliest_collision.is_empty() or ccd_res[1] < earliest_collision[1]:
					earliest_collision = ccd_res
					collision_rect = i
		
		var collision_with_platform : bool = false
		if -1 not in banned_rect_side:
			var platform_ccd_collision : Array = ArcanoidGeometry.ccd_circle_box(
				ball_position,
				ball_position+_game_state.ball_velocity*delta,
				_game_state.ball_radius,
				platform_rect
			)
			if 0.0 < platform_ccd_collision[1] and platform_ccd_collision[1] < (1.0-frametime):
				if earliest_collision.is_empty() or platform_ccd_collision[1] < earliest_collision[1]:
					earliest_collision = platform_ccd_collision
					collision_with_platform = true
					collision_rect = -1
		
		if earliest_collision.is_empty():
			ball_position += _game_state.ball_velocity*delta*(1.0-frametime)
			break
		
		ball_position += _game_state.ball_velocity*delta*earliest_collision[1]
		frametime += earliest_collision[1]
		if collision_with_platform:
			_game_state.ball_velocity = (ball_position-_game_state.platform_rect.get_center()).normalized() * _game_state.ball_velocity.length()
		elif (earliest_collision[2] == SIDE_TOP or earliest_collision[2] == SIDE_BOTTOM):
			_game_state.ball_velocity.y *= -1
		else:
			_game_state.ball_velocity.x *= -1
		
		banned_rect_side = [collision_rect, earliest_collision[2]]
	
	_game_state.ball_position = ball_position


func _place_ball_to_launch_position() -> void:
	const BALL_PLATFORM_GAP : float = 3.0
	
	_game_state.ball_position = _game_state.platform_rect.position + \\
		Vector2(_game_state.platform_rect.size.x*randf(), -_game_state.ball_radius-BALL_PLATFORM_GAP)


func _handle_platform_movement(delta:float) -> void:
	var platform_speed_input : float = Input.get_axis(\"platform_left\", \"platform_right\")
	
	_game_state.platform_rect.position.x += _game_state.platform_speed*delta*platform_speed_input
	if _game_state.platform_rect.end.x > _game_state.playing_area_rect.end.x:
		_game_state.platform_rect.position.x = _game_state.playing_area_rect.end.x-_game_state.platform_rect.size.x
	elif _game_state.platform_rect.position.x < _game_state.playing_area_rect.position.x:
		_game_state.platform_rect.position.x = _game_state.playing_area_rect.position.x


func _on_start_button_pressed() -> void:
	(%StartButton as Button).hide()
	_game_state.state_machine.go_state(GameState.LAUNCHING_BALL_STATE)
"

[node name="ArcanoidGame" type="Node"]

[node name="Drawer" type="Node2D" parent="."]
script = SubResource("GDScript_vuba5")

[node name="BlockController" type="Node" parent="."]
script = SubResource("GDScript_0ctov")

[node name="GameController" type="Node" parent="."]
script = SubResource("GDScript_ypwq7")

[node name="StartButton" type="Button" parent="."]
unique_name_in_owner = true
offset_left = 94.0
offset_top = 260.0
offset_right = 408.0
offset_bottom = 369.0
focus_mode = 0
text = "START"

[node name="GameState" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("3_6rb05")

[connection signal="pressed" from="StartButton" to="GameController" method="_on_start_button_pressed"]
