[gd_scene load_steps=4 format=3 uid="uid://bixm1xmwh4h83"]

[ext_resource type="Script" path="res://scenes/GameState.gd" id="3_6rb05"]

[sub_resource type="GDScript" id="GDScript_vuba5"]
resource_name = "drawer"
script/source = "extends Node2D

@onready
var _game_state : GameState = %GameState 

func _process(delta: float) -> void:
	queue_redraw()

func _draw() -> void:
	draw_circle(_game_state.ball_position, 
		_game_state.ball_radius-_game_state.ball_draw_width/2.0, 
		_game_state.ball_color, false, _game_state.ball_draw_width, true)
	
	draw_rect(_game_state.platform_rect.grow(-_game_state.platform_draw_width/2.0), 
	_game_state.platform_color, false, _game_state.platform_draw_width, false
	)
	
	for block:Rect2 in _game_state.blocks:
		draw_rect(block.grow(-_game_state.block_draw_width/2.0), 
		_game_state.block_color, false, _game_state.block_draw_width, false
		)
"

[sub_resource type="GDScript" id="GDScript_ypwq7"]
resource_name = "game_controller"
script/source = "extends Node

@onready
var _game_state : GameState = %GameState

enum BallCollisionTypes {
	BORDER,
	PLATFORM,
	BLOCK
}

func _ready() -> void:
	_game_state.state_machine.handle_state(GameState.GAME_STARTING_STATE, _on_state_game_starting)
	_game_state.state_machine.handle_state(GameState.LAUNCHING_BALL_STATE, _on_state_launching_ball)
	_game_state.state_machine.handle_state(GameState.CONTROLLING_BALL_STATE, _on_state_controlling_ball)
	
	_game_state.state_machine.state = GameState.GAME_STARTING_STATE


func _on_state_game_starting() -> void:
	_game_state.platform_rect.position = Vector2(
		_game_state.playing_area_rect.position.x+_game_state.playing_area_rect.size.x/2.0 -_game_state.platform_rect.size.x/2.0, 
		_game_state.playing_area_rect.end.y-_game_state.platform_height-_game_state.platform_rect.size.y)
	
	_place_ball_to_launch_position()
	_spawn_blocks_layer()


func _on_state_launching_ball() -> void:
	_place_ball_to_launch_position()


func _on_state_controlling_ball() -> void:
	pass


func _process(delta: float) -> void:
	match _game_state.state_machine.state:
		GameState.GAME_STARTING_STATE:
			_process_game_starting(delta)
		GameState.LAUNCHING_BALL_STATE:
			_process_launching_ball(delta)
		GameState.CONTROLLING_BALL_STATE:
			_process_controlling_ball(delta)


func _process_game_starting(delta:float) -> void:
	pass


func _process_launching_ball(delta:float) -> void:
	var ball_relative_position : Vector2 = _game_state.ball_position - _game_state.platform_rect.position
	_handle_platform_movement(delta)
	_game_state.ball_position = _game_state.platform_rect.position + ball_relative_position
	
	if Input.is_action_just_pressed(\"platform_launch_ball\"):
		var launch_direction : Vector2 = (_game_state.ball_position - _game_state.platform_rect.get_center()).normalized()
		_game_state.ball_velocity = launch_direction*_game_state.ball_velocity.length()
		_game_state.state_machine.go_state(GameState.CONTROLLING_BALL_STATE)


func _process_controlling_ball(delta:float) -> void:
	const PLATFORM_HEIGHT : float = 20.0
	
	_handle_platform_movement(delta)
	
	var playing_area_limiter_rect : Rect2 = _game_state.playing_area_rect.grow(-_game_state.ball_radius*2)
	var platform_rect : Rect2 = _game_state.platform_rect
	
	var frametime : float = 0.0
	var banned_rect_side : Array[int] = [] # rect idx, side idx, group idx
	
	var collide_group : Callable = func(rect_group:Array[Rect2], group_idx:int, banned_rect:Array, frame_time:float):
		var earliest_collision : Array = []
		var collision_rect : int
		for i:int in len(rect_group):
			var rect : Rect2 = rect_group[i]
			var ccd_res : Array = ArcanoidGeometry.ccd_circle_box(
				_game_state.ball_position, 
				_game_state.ball_position+_game_state.ball_velocity*delta,
				_game_state.ball_radius,
				rect, [banned_rect[1]] if 
					(not banned_rect.is_empty() and i == banned_rect[0] and group_idx == banned_rect[2]) else []) 
			
			if not ccd_res[0]: continue
			
			if 0.0 <= ccd_res[1] and ccd_res[1] <= (1.0-frame_time):
				if earliest_collision.is_empty() or ccd_res[1] < earliest_collision[1]:
					earliest_collision = ccd_res
					collision_rect = i
		
		if earliest_collision.is_empty(): 
			earliest_collision = [false, 0.0, 1]
		return [earliest_collision, collision_rect]
	
	
	while true:
		var earliest_collision : Array = []
		var collision_rect : int
		var collision_type : BallCollisionTypes
		
		var collision_with_borders : Array = collide_group.call([playing_area_limiter_rect] as Array[Rect2], BallCollisionTypes.BORDER, banned_rect_side, frametime)
		var collsion_with_platform : Array = collide_group.call([platform_rect] as Array[Rect2], BallCollisionTypes.PLATFORM, banned_rect_side, frametime)
		var collision_with_blocks : Array = collide_group.call(_game_state.blocks as Array[Rect2], BallCollisionTypes.BLOCK, banned_rect_side, frametime)
		
		if collision_with_borders[0][0]:
			earliest_collision = collision_with_borders[0]
			collision_rect = collision_with_borders[1]
			collision_type = BallCollisionTypes.BORDER
		
		if collsion_with_platform[0][0] and (earliest_collision.is_empty() or collsion_with_platform[0][1] < earliest_collision[1]):
			earliest_collision = collsion_with_platform[0]
			collision_rect = collsion_with_platform[1]
			collision_type = BallCollisionTypes.PLATFORM
		
		if collision_with_blocks[0][0] and (earliest_collision.is_empty() or collision_with_blocks[0][1] < earliest_collision[1]):
			earliest_collision = collision_with_blocks[0]
			collision_rect = collision_with_blocks[1]
			collision_type = BallCollisionTypes.BLOCK
		
		if earliest_collision.is_empty():
			_game_state.ball_position += _game_state.ball_velocity*delta*(1.0-frametime)
			break
		
		_game_state.ball_position += _game_state.ball_velocity*delta*earliest_collision[1]
		frametime += earliest_collision[1]
		
		match collision_type:
			BallCollisionTypes.BORDER:
				if earliest_collision[2] == SIDE_BOTTOM:
					_game_state.state_machine.go_state(GameState.LAUNCHING_BALL_STATE)
					return
				
				if (earliest_collision[2] == SIDE_TOP or earliest_collision[2] == SIDE_BOTTOM):
					_game_state.ball_velocity.y *= -1
				else:
					_game_state.ball_velocity.x *= -1
				banned_rect_side = [collision_rect, earliest_collision[2], BallCollisionTypes.BORDER]
				
			BallCollisionTypes.PLATFORM:
				_game_state.ball_velocity = (_game_state.ball_position-_game_state.platform_rect.get_center()).normalized() * _game_state.ball_velocity.length()
				_on_ball_platform_collision.call_deferred()
				banned_rect_side = [collision_rect, earliest_collision[2], BallCollisionTypes.PLATFORM]
				
			BallCollisionTypes.BLOCK:
				_game_state.blocks.remove_at(collision_rect)
				if (earliest_collision[2] == SIDE_TOP or earliest_collision[2] == SIDE_BOTTOM):
					_game_state.ball_velocity.y *= -1
				else:
					_game_state.ball_velocity.x *= -1
				banned_rect_side = []
		


func _place_ball_to_launch_position() -> void:
	const BALL_PLATFORM_GAP : float = 3.0
	
	_game_state.ball_position = _game_state.platform_rect.position + \\
		Vector2(_game_state.platform_rect.size.x*randf(), -_game_state.ball_radius-BALL_PLATFORM_GAP)


func _handle_platform_movement(delta:float) -> void:
	var platform_speed_input : float = Input.get_axis(\"platform_left\", \"platform_right\")
	
	_game_state.platform_rect.position.x += _game_state.platform_speed*delta*platform_speed_input
	if _game_state.platform_rect.end.x > _game_state.playing_area_rect.end.x:
		_game_state.platform_rect.position.x = _game_state.playing_area_rect.end.x-_game_state.platform_rect.size.x
	elif _game_state.platform_rect.position.x < _game_state.playing_area_rect.position.x:
		_game_state.platform_rect.position.x = _game_state.playing_area_rect.position.x



func _spawn_blocks_layer() -> void:
	for i:int in len(_game_state.blocks):
		_game_state.blocks[i].position.y += _game_state.block_size.y + _game_state.block_rows_gap
	
	var spawned_columns : Array[int] = []
	var spawn_count : int = min(_game_state.blocks_spawn_count, _game_state.blocks_columns)
	var x_offset : float = (_game_state.playing_area_rect.size.x - \\
			(_game_state.block_size.x+_game_state.blocks_columns_gap)*_game_state.blocks_columns)/2.0
	
	for i:int in spawn_count:
		var column : int = randi()%_game_state.blocks_columns
		while column in spawned_columns: column = randi()%_game_state.blocks_columns
		spawned_columns.append(column)
		var new_block : Rect2 = Rect2(
			_game_state.playing_area_rect.position + \\
				Vector2(_game_state.block_size.x+_game_state.blocks_columns_gap, 0.0)*column + \\
				Vector2(x_offset, 0.0),
			_game_state.block_size
		)
		
		_game_state.blocks.append(new_block)


func _on_ball_platform_collision() -> void:
	_spawn_blocks_layer()


func _on_start_button_pressed() -> void:
	(%StartButton as Button).hide()
	_game_state.state_machine.go_state(GameState.LAUNCHING_BALL_STATE)
"

[node name="ArcanoidGame" type="Node"]

[node name="Drawer" type="Node2D" parent="."]
script = SubResource("GDScript_vuba5")

[node name="GameController" type="Node" parent="."]
script = SubResource("GDScript_ypwq7")

[node name="StartButton" type="Button" parent="."]
unique_name_in_owner = true
offset_left = 94.0
offset_top = 260.0
offset_right = 408.0
offset_bottom = 369.0
focus_mode = 0
text = "START"

[node name="GameState" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("3_6rb05")
initial_ball_radius = 5.0
initial_ball_speed = 500.0
initial_platform_size = Vector2(80, 10)
initial_platform_speed = 400.0
platform_height = 10.0
block_size = Vector2(50, 20)
block_rows_gap = 2.0
blocks_columns_gap = 2.0
initial_block_spawn_amount = 3

[connection signal="pressed" from="StartButton" to="GameController" method="_on_start_button_pressed"]
