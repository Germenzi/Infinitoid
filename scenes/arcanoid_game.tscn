[gd_scene load_steps=14 format=3 uid="uid://bixm1xmwh4h83"]

[ext_resource type="Theme" uid="uid://dmce53ilrrlem" path="res://main-theme.tres" id="2_665qb"]
[ext_resource type="Script" path="res://scripts/GameState.gd" id="3_6rb05"]
[ext_resource type="PackedScene" uid="uid://dj4cqaqhhkqus" path="res://scenes/game_starting_ui.tscn" id="3_ricfi"]

[sub_resource type="GDScript" id="GDScript_vuba5"]
resource_name = "drawer"
script/source = "extends Node2D

@onready
var _game_state : GameState = %GameState 

func _process(delta: float) -> void:
	queue_redraw()

func _draw() -> void:
	draw_circle(_game_state.ball_position, 
		_game_state.ball_radius-_game_state.ball_draw_width/2.0, 
		_game_state.ball_color, false, _game_state.ball_draw_width, true)
	
	draw_rect(_game_state.platform_rect.grow(-_game_state.platform_draw_width/2.0), 
	_game_state.platform_color, false, _game_state.platform_draw_width, false
	)
	
	for block:Rect2 in _game_state.blocks:
		draw_rect(block.grow(-_game_state.block_draw_width/2.0), 
		_game_state.block_color, false, _game_state.block_draw_width, false
		)
	
	draw_line(_game_state.playing_area_rect.position+Vector2(0, _game_state.blocks_deadline_height), 
		_game_state.playing_area_rect.position+Vector2(_game_state.playing_area_rect.size.x, _game_state.blocks_deadline_height), 
		Color(_game_state.block_color, 0.3), _game_state.block_draw_width, true)
"

[sub_resource type="GDScript" id="GDScript_ypwq7"]
resource_name = "game_controller"
script/source = "extends Node

@onready
var _game_state : GameState = %GameState

enum BallCollisionTypes {
	BORDER,
	PLATFORM,
	BLOCK
}

var chosen_ability : Ability

func _ready() -> void:
	_game_state.state_machine.handle_state(GameState.GAME_STARTING_STATE, _on_state_game_starting)
	_game_state.state_machine.handle_state(GameState.LAUNCHING_BALL_STATE, _on_state_launching_ball)
	_game_state.state_machine.handle_state(GameState.CONTROLLING_BALL_STATE, _on_state_controlling_ball)
	
	_game_state.state_machine.state = GameState.GAME_STARTING_STATE


func _on_state_game_starting() -> void:
	_game_state.platform_rect.position = Vector2(
		_game_state.playing_area_rect.position.x+_game_state.playing_area_rect.size.x/2.0 -_game_state.platform_rect.size.x/2.0, 
		_game_state.playing_area_rect.end.y-_game_state.platform_height-_game_state.platform_rect.size.y)
	print(_game_state.playing_area_rect)
	_place_ball_to_launch_position()
	for i:int in _game_state.initial_block_rows:
		_spawn_blocks_layer()


func _on_state_launching_ball() -> void:
	chosen_ability.deactivate()
	_place_ball_to_launch_position()


func _on_state_controlling_ball() -> void:
	pass


func _process(delta: float) -> void:
	match _game_state.state_machine.state:
		GameState.GAME_STARTING_STATE:
			_process_game_starting(delta)
		GameState.LAUNCHING_BALL_STATE:
			_process_launching_ball(delta)
		GameState.CONTROLLING_BALL_STATE:
			_process_controlling_ball(delta)


func _process_game_starting(delta:float) -> void:
	pass


func _process_launching_ball(delta:float) -> void:
	var ball_relative_position : Vector2 = _game_state.ball_position - _game_state.platform_rect.position
	_handle_platform_movement(delta)
	_game_state.ball_position = _game_state.platform_rect.position + ball_relative_position
	
	if Input.is_action_just_pressed(\"platform_launch_ball\"):
		var launch_direction : Vector2 = (_game_state.ball_position - _game_state.platform_rect.get_center()).normalized()
		_game_state.ball_velocity = launch_direction*_game_state.ball_velocity.length()
		_game_state.state_machine.go_state(GameState.CONTROLLING_BALL_STATE)


func _process_controlling_ball(delta:float) -> void:
	const PLATFORM_HEIGHT : float = 20.0
	
	_handle_platform_movement(delta)
	
	if Input.is_action_just_pressed(\"platform_launch_ball\"):
		if chosen_ability != null:
			chosen_ability.activate()
	
	if Input.is_action_just_released(\"platform_launch_ball\"):
		if chosen_ability != null:
				chosen_ability.deactivate()
	
	var playing_area_limiter_rect : Rect2 = _game_state.playing_area_rect.grow(-_game_state.ball_radius*2)
	var platform_rect : Rect2 = _game_state.platform_rect
	
	var old_ball_position : Vector2 = _game_state.ball_position
	var old_ball_velocity : Vector2 = _game_state.ball_velocity
	
	var frametime : float = 0.0
	var banned_rects_sides := ArcanoidGeometry.RectGroupBannedSides.new()
	while true:
		var earliest_collision : ArcanoidGeometry.BallCollisionResultGroup = null
		var collision_type : BallCollisionTypes
		
		var collision_with_borders := ArcanoidGeometry.ccd_circle_box_group(
				_game_state.ball_position, _game_state.ball_position+_game_state.ball_velocity*delta, _game_state.ball_radius,
				[playing_area_limiter_rect] as Array[Rect2], banned_rects_sides)
			
		var collsion_with_platform := ArcanoidGeometry.ccd_circle_box_group(
				_game_state.ball_position, _game_state.ball_position+_game_state.ball_velocity*delta, _game_state.ball_radius,
				[platform_rect] as Array[Rect2], banned_rects_sides)
		
		var collision_with_blocks := ArcanoidGeometry.ccd_circle_box_group(
				_game_state.ball_position, _game_state.ball_position+_game_state.ball_velocity*delta, _game_state.ball_radius,
				_game_state.blocks, banned_rects_sides)
			
		if collision_with_borders != null:
			earliest_collision = collision_with_borders
			collision_type = BallCollisionTypes.BORDER
		
		if collsion_with_platform != null and (earliest_collision == null or collsion_with_platform.collision_time < earliest_collision.collision_time):
			earliest_collision = collsion_with_platform
			collision_type = BallCollisionTypes.PLATFORM
		
		if collision_with_blocks != null and (earliest_collision == null  or collision_with_blocks.collision_time < earliest_collision.collision_time):
			earliest_collision = collision_with_blocks
			collision_type = BallCollisionTypes.BLOCK
		
		if earliest_collision == null:
			_game_state.ball_position += _game_state.ball_velocity*delta*(1.0-frametime)
			break
		
		_game_state.ball_position += _game_state.ball_velocity*delta*earliest_collision.collision_time
		frametime += earliest_collision.collision_time
		
		match collision_type:
			BallCollisionTypes.BORDER:
				if earliest_collision.collided_rect_side == SIDE_BOTTOM:
					_on_ball_falled()
					return
				
				if (earliest_collision.collided_rect_side == SIDE_TOP or earliest_collision.collided_rect_side == SIDE_BOTTOM):
					_game_state.ball_velocity.y *= -1
				else:
					_game_state.ball_velocity.x *= -1
				banned_rects_sides = ArcanoidGeometry.RectGroupBannedSides.new()
				banned_rects_sides.ban_side(earliest_collision.collision_rect_index, earliest_collision.collided_rect_side)
				
			BallCollisionTypes.PLATFORM:
				_game_state.ball_velocity = (_game_state.ball_position-_game_state.platform_rect.get_center()-Vector2(0, 20)).normalized() * _game_state.ball_velocity.length()
				_on_ball_platform_collision.call_deferred()
				banned_rects_sides = ArcanoidGeometry.RectGroupBannedSides.new()
				banned_rects_sides.ban_side(earliest_collision.collision_rect_index, earliest_collision.collided_rect_side)
				
			BallCollisionTypes.BLOCK:
				_game_state.blocks.remove_at(earliest_collision.collision_rect_index)
				if (earliest_collision.collided_rect_side == SIDE_TOP or earliest_collision.collided_rect_side == SIDE_BOTTOM):
					_game_state.ball_velocity.y *= -1
				else:
					_game_state.ball_velocity.x *= -1
				_game_state.score += 1
				banned_rects_sides = ArcanoidGeometry.RectGroupBannedSides.new()
	
	# hardcoded bugfix, when ball super rarely just ignore walls
	if not _game_state.playing_area_rect.grow(-_game_state.ball_radius).has_point(_game_state.ball_position):
		if _game_state.ball_position.x <= _game_state.playing_area_rect.position.x:
			_game_state.ball_position.x = _game_state.playing_area_rect.position.x + _game_state.ball_radius + 4.0
			_game_state.ball_velocity.x *= -1
		elif  _game_state.ball_position.x >= _game_state.playing_area_rect.end.x:
			_game_state.ball_position.x = _game_state.playing_area_rect.end.x - _game_state.ball_radius - 4.0
			_game_state.ball_velocity.x *= -1
		
		if _game_state.ball_position.y <= _game_state.playing_area_rect.position.y:
			_game_state.ball_velocity.y *= -1
			_game_state.ball_position.y = _game_state.playing_area_rect.position.y + _game_state.ball_radius + 4.0
		elif _game_state.ball_position.y >= _game_state.playing_area_rect.end.y:
			_on_ball_falled()
		print(\"TRUTEN\")

func _place_ball_to_launch_position() -> void:
	const BALL_PLATFORM_GAP : float = 2.0
	
	_game_state.ball_position = _game_state.platform_rect.position + \\
		Vector2(_game_state.platform_rect.size.x*randf(), -_game_state.ball_radius-BALL_PLATFORM_GAP)


func _handle_platform_movement(delta:float) -> void:
	var platform_speed_input : float = Input.get_axis(\"platform_left\", \"platform_right\")
	
	_game_state.platform_rect.position.x += _game_state.platform_speed*delta*platform_speed_input
	if _game_state.platform_rect.end.x > _game_state.playing_area_rect.end.x:
		_game_state.platform_rect.position.x = _game_state.playing_area_rect.end.x-_game_state.platform_rect.size.x
	elif _game_state.platform_rect.position.x < _game_state.playing_area_rect.position.x:
		_game_state.platform_rect.position.x = _game_state.playing_area_rect.position.x



func _spawn_blocks_layer() -> void:
	for i:int in len(_game_state.blocks):
		_game_state.blocks[i].position.y += _game_state.block_size.y + _game_state.block_rows_gap
		if _game_state.blocks[i].end.y > _game_state.blocks_deadline_height:
			_on_blocks_reached_deadline()
			return

	var spawned_columns : Array[int] = []
	var spawn_count : int = min(_game_state.blocks_spawn_count, _game_state.blocks_columns)
	var x_offset : float = (_game_state.playing_area_rect.size.x - \\
			(_game_state.block_size.x+_game_state.blocks_columns_gap)*_game_state.blocks_columns)/2.0
	
	for i:int in spawn_count:
		var column : int = randi()%_game_state.blocks_columns
		while column in spawned_columns: column = randi()%_game_state.blocks_columns
		spawned_columns.append(column)
		var new_block : Rect2 = Rect2(
			_game_state.playing_area_rect.position + \\
				Vector2(_game_state.block_size.x+_game_state.blocks_columns_gap, 0.0)*column + \\
				Vector2(x_offset, _game_state.top_row_gap),
			_game_state.block_size
		)
		
		_game_state.blocks.append(new_block)


func _on_ball_platform_collision() -> void:
	_spawn_blocks_layer()
	_game_state.ball_velocity *= _game_state.speed_factor
	_game_state.platform_speed *= _game_state.speed_factor


func _on_ball_falled() -> void:
	_game_state.state_machine.go_state(GameState.LAUNCHING_BALL_STATE)
	_game_state.health -= 1
	
	if _game_state.health <= 0:
		_on_health_expired()


func _on_blocks_reached_deadline() -> void:
	_game_state.blocks = []
	for i:int in _game_state.initial_block_rows:
		_spawn_blocks_layer()
	_game_state.health -= 1
	if _game_state.health <= 0:
		_on_health_expired()
	else:
		_game_state.state_machine.go_state(GameState.LAUNCHING_BALL_STATE)


func _on_health_expired() -> void:
	get_tree().reload_current_scene()


func _on_game_starging_ui_start_button_pressed(ability:GameAbilitiesNamespace.Types) -> void:
	(%GameStartingUI as Control).hide()
	match ability:
		GameAbilitiesNamespace.Types.SLOWTIME:
			chosen_ability = $SlowtimeAbility
		GameAbilitiesNamespace.Types.SHOW_BALL_TRAJECTORY:
			chosen_ability = $BallTrajectroryAbility
		GameAbilitiesNamespace.Types.PLATFORM_ACCELERATION:
			chosen_ability = $PlatformAccelerationAbility
		GameAbilitiesNamespace.Types.PLATFORM_EXTENSION:
			chosen_ability = $PlatformExtensionAbility
		GameAbilitiesNamespace.Types.MAGNETISM:
			chosen_ability = $MagnetismAbility
	
	_game_state.state_machine.go_state(GameState.LAUNCHING_BALL_STATE)


func _on_drawer_draw() -> void:
	if not chosen_ability:
		return
	
	(%Drawer as CanvasItem).draw_rect(_game_state.platform_rect.grow_side(SIDE_RIGHT,
		-_game_state.platform_rect.size.x*(1.0-chosen_ability.relative_balance)),
		_game_state.platform_color)
"

[sub_resource type="GDScript" id="GDScript_khgdo"]
resource_name = "slowtime_ability"
script/source = "extends Ability


@onready 
var _game_state: GameState = %GameState

@export_range(0.1, 1.0)
var slow_time_value : float = 0.3


func _on_activated() -> void:
	_active = true
	Engine.time_scale = slow_time_value


func _on_deactivated() -> void:
	_active = false
	Engine.time_scale = 1.0
"

[sub_resource type="GDScript" id="GDScript_jnwm8"]
resource_name = "ball_trajectory_ability"
script/source = "extends Ability

@onready 
var _game_state: GameState = %GameState


func _on_drawer_draw() -> void:
	if not _active:
		return
	
	if _game_state.state_machine.state != GameState.CONTROLLING_BALL_STATE:
		return
	
	(%Drawer as CanvasItem).draw_line(_game_state.ball_position, 
		_game_state.ball_position+_game_state.ball_velocity, 
		_game_state.ball_color, 1.0, true)
"

[sub_resource type="GDScript" id="GDScript_col8f"]
resource_name = "platform_acceleration_ability"
script/source = "extends Ability

@onready 
var _game_state: GameState = %GameState

@export_range(1.0, 5.0)
var acceleration_value : float = 1.1

func _on_activated() -> void:
	_active = true
	_game_state.platform_speed *= acceleration_value


func _on_deactivated() -> void:
	_active = false
	_game_state.platform_speed /= acceleration_value
"

[sub_resource type="GDScript" id="GDScript_1clpx"]
resource_name = "platform_extension_ability"
script/source = "extends Ability

@export_range(0.0, 1_000.0)
var extension_distance : float = 20.0

@onready
var _game_state: GameState = %GameState

func _on_activated() -> void:
	_game_state.platform_rect = _game_state.platform_rect.grow_individual(extension_distance, 0.0, extension_distance, 0.0)


func _on_deactivated() -> void:
	_game_state.platform_rect = _game_state.platform_rect.grow_individual(-extension_distance, 0.0, -extension_distance, 0.0)
"

[sub_resource type="GDScript" id="GDScript_6431r"]
resource_name = "magnetism_ability"
script/source = "extends Ability

@export_range(0.0, 100.0)
var magnetism_power : float = 10.0

@onready 
var _game_state: GameState = %GameState


func _process(delta: float) -> void:
	super(delta)
	if not _active:
		return
	
	var acceleration : Vector2 = \\
		(_game_state.platform_rect.get_center() - _game_state.ball_position).normalized()*magnetism_power
	var speed : float = _game_state.ball_velocity.length()
	_game_state.ball_velocity = (_game_state.ball_velocity+acceleration).normalized()*speed
"

[sub_resource type="GDScript" id="GDScript_0skvr"]
resource_name = "speed_label"
script/source = "extends Label

@onready
var _game_state : GameState = %GameState

func _process(delta: float) -> void:
	text = \"Ball speed: %.0f\" % _game_state.ball_velocity.length()
"

[sub_resource type="GDScript" id="GDScript_fgexy"]
resource_name = "health_label"
script/source = "extends Label

@onready
var _game_state : GameState = %GameState

func _process(delta: float) -> void:
	text = \"Health: %d/%d\" % [_game_state.health, _game_state.maximum_health]
"

[sub_resource type="GDScript" id="GDScript_4yrex"]
resource_name = "score_label"
script/source = "extends Label

@onready
var _game_state : GameState = %GameState

func _process(delta: float) -> void:
	text = \"Score: %d\" % _game_state.score
"

[node name="ArcanoidGame" type="Node"]

[node name="Drawer" type="Node2D" parent="."]
unique_name_in_owner = true
script = SubResource("GDScript_vuba5")

[node name="GameController" type="Node" parent="."]
unique_name_in_owner = true
script = SubResource("GDScript_ypwq7")

[node name="SlowtimeAbility" type="Node" parent="GameController"]
script = SubResource("GDScript_khgdo")
time_capacity = 0.3
time_remains_recovery_scale = 0.25

[node name="BallTrajectroryAbility" type="Node" parent="GameController"]
script = SubResource("GDScript_jnwm8")
time_remains_recovery_scale = 0.25

[node name="PlatformAccelerationAbility" type="Node" parent="GameController"]
script = SubResource("GDScript_col8f")
acceleration_value = 2.0
time_remains_recovery_scale = 0.25

[node name="PlatformExtensionAbility" type="Node" parent="GameController"]
script = SubResource("GDScript_1clpx")

[node name="MagnetismAbility" type="Node" parent="GameController"]
script = SubResource("GDScript_6431r")
magnetism_power = 20.0

[node name="GameState" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("3_6rb05")
initial_ball_radius = 7.0
initial_ball_speed = 500.0
initial_platform_size = Vector2(80, 10)
initial_platform_speed = 400.0
platform_height = 10.0
block_size = Vector2(70, 20)
block_rows_gap = 2.0
blocks_columns_gap = 2.0
initial_block_spawn_amount = 5
blocks_deadline_height = 600.0
top_row_gap = 30.0

[node name="GUI" type="CanvasLayer" parent="."]
layer = 3

[node name="Control" type="Control" parent="GUI"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_665qb")

[node name="SpeedLabel" type="Label" parent="GUI/Control"]
layout_mode = 0
offset_right = 95.0
offset_bottom = 39.0
script = SubResource("GDScript_0skvr")

[node name="HealthLabel" type="Label" parent="GUI/Control"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -40.0
offset_bottom = 23.0
grow_horizontal = 0
script = SubResource("GDScript_fgexy")

[node name="ScoreLabel" type="Label" parent="GUI/Control"]
layout_mode = 1
anchors_preset = 5
anchor_left = 0.5
anchor_right = 0.5
offset_left = -20.0
offset_right = 20.0
offset_bottom = 23.0
grow_horizontal = 2
script = SubResource("GDScript_4yrex")

[node name="GameStartingUI" parent="GUI/Control" instance=ExtResource("3_ricfi")]
unique_name_in_owner = true
layout_mode = 1

[connection signal="draw" from="Drawer" to="GameController" method="_on_drawer_draw"]
[connection signal="draw" from="Drawer" to="GameController/BallTrajectroryAbility" method="_on_drawer_draw"]
[connection signal="start_button_pressed" from="GUI/Control/GameStartingUI" to="GameController" method="_on_game_starging_ui_start_button_pressed"]
